# -*- coding: utf-8 -*-
"""
Created on Thu Jul 10 14:43:44 2014

@author: Laurent
"""

################################ 
#        Importing dependencies       
################################ 
#Natives
import os, shutil, sys, copy
from scipy.stats import t, chi2
from scipy.stats.mstats import kruskalwallis

#Internal
import lib.tools_write as write
import lib.vissim as vissim
import lib.outputs as outputs
import lib.define as define

################################ 
#        Calibration analysis       
################################

def checkCorrespondanceOfOutputs(video_value, calculated_value):
    '''Test a range of values with the kruskalwallis test'''

    H_statistic_list = []
    p_value_list = []

    for i in range(len(calculated_value)):    
        H_statistic, p_value = kruskalwallis(video_value[i].cumul_all.raw, calculated_value[i].cumul_all.raw)

        H_statistic_list.append(H_statistic)
        p_value_list.append(p_value)
    
    return p_value_list    


def calculateOnePass(values, foldername, inputs):
    '''Note: Vissim will be opened by this function. It must be closed out of it'''
    
    #unpacking inputs
    commands    = inputs[0]
    config      = inputs[1]
    outputspath = inputs[2]
    parameters  = inputs[3]
    Inpxname    = inputs[4]
    InpxPath    = inputs[5]
    brutename   = inputs[6]
    value_names = inputs[7]
    video_value = inputs[8]
    Vissim      = inputs[9]
    multi       = inputs[10]
    
    if multi is True:
        for i,j in enumerate(inputs[11]):
            if values == j:
                foldername = brutename.split('_')[0] + '_' + str( int(brutename.split('_')[1]) + i )

    else:
        foldername = brutename

    #creating a folder containing the files for that iteration
    folderpath, filename = prepareFolderforVissimAnalysis(outputspath, foldername, Inpxname, InpxPath)
    
    p_values = []
    if commands.mode:  #this serves to bypass Vissim while testing the code
        flow, oppLCcount, manLCcount, forFMgap, oppLCagap, oppLCbgap, manLCagap, manLCbgap = outputs.generateRandomOutputs(parameters)
        
    else:
        Vissim.LoadNet (os.path.join(folderpath, filename))        
        
        #Initializing and running the simulation
        simulated = vissim.initializeSimulation(Vissim, parameters, values, value_names)
        
        if simulated is not True:
            print 'Could not run the Vissim simulation for ' + str(foldername)
            sys.exit()
            
        else:
            #treating the outputs
            inputs = [outputspath, config.sim_steps, config.warm_up_time]
            flow, oppLCcount, manLCcount, forFMgap, oppLCagap, oppLCbgap, manLCagap, manLCbgap = outputs.treatVissimOutputs([f for f in os.listdir(folderpath) if f.endswith("fzp")], inputs)
            
    #checking the correspondance to the real data values
    if config.output_forward_gaps:
        calculated_values = [forFMgap, flow]
    if config.output_lane_change:
        calculated_values = [oppLCagap, flow]
        
    p_values = p_values + checkCorrespondanceOfOutputs(video_value, calculated_values)

    return p_values
        
def runVissimForCalibrationAnalysis(inputvalues, inputs, multi):
    '''handles two type of inputs:
            one generated by intelligentChunks --> inputvalues = [[[values we need],i],[[values we need],i],...]
            one generated by cleanChunks       --> inputvalues = [[values we need],[values we need],...]
    '''
    #unpacking inputs
    commands    = inputs[0]  
    
    if multi is True:
        #if only one point was valid, no need to spawn processes
        if len(inputvalues) == 1:
            multi = False
            inputvalues = inputvalues[0]
            
        else:
            inputs.append(inputvalues)
            p_values = define.createWorkers(inputvalues, calculateOnePass, inputs, commands)
    
    if multi is False:
        p_values = calculateOnePass(inputvalues, inputs)
    
    return p_values


def respectUniverseBoundaries(destination,hard_bounds):
    '''verifies if the destination is within the boundaries. Else, returns False'''
    
    point_in = True
    for i in range(len(destination)):
        #gathering informations on symetric equations: (x-x0)/a = (y-y0)/b = ... = (n-n0)/m

        if hard_bounds[i][0] is not None:        
            if destination[i] < hard_bounds[i][0]:      
                point_in = False
                
        elif hard_bounds[i][1] is not None:
            if destination[i] > hard_bounds[i][1]:
                point_in = False
            
    return point_in

################################ 
#        Statistical precision analysis       
################################

def statistical_ana(concat_variables, default_values, filename, InpxPath, InpxName, outputspath, graphspath, config, commands, running, parameters):
    '''Finds the number of iterations needed to achieve a good confidence interval
    
    Base on the ODOT specifications:
        1. run 10 simulations and calculates the median and standard deviation for the outputs
        2. run the Student t-test while fixing the confidence interval to +/- err*mu
                   where err is the %error on the mean value, specified in the cfg file.
                   --> N = [t(1-alpha/2;N-1)*S/(err*mu)]^2 with aplha = 0.975 (bivariate 95% confidence)
            2a. calculate the confidence interval for the standard deviation
            
        3. check if N > number of simulations ran up to this point
        4. if yes, run one more simulation and repeat steps 2, 3 and 4 until "number of simulations" >= N
        
    '''
    max_itt = 25    #might consider adding it to the cfg file    
    
    text = []
   
    #set the number of runs to 10
    first_seed = parameters[1]    
    parameters[2] = 10
    iterrations_ran = 10
    
    #renaming the inpx and moving it to the output folder
    if os.path.exists(os.path.join(outputspath, "Statistical_test.inpx")) is False:
        shutil.copy(InpxPath, os.path.join(outputspath, InpxName))
        os.rename(os.path.join(outputspath, InpxName), os.path.join(outputspath, "Statistical_test.inpx"))
    
    if commands.verbose is True:
        print 'Starting the first 10 runs'
    
    if commands.mode:  #this serves to bypass Vissim while testing the code
        flow, oppLCcount, manLCcount, forFMgap, oppLCagap, oppLCbgap, manLCagap, manLCbgap = outputs.generateRandomOutputs(parameters)
    else:
        Vissim = vissim.startVissim(running, os.path.join(outputspath,  "Statistical_test.inpx"))
                            
        #Vissim initialisation and simulation running                                                   
        simulated = vissim.initializeSimulation(Vissim, parameters, default_values, concat_variables, commands.save_swp)
        
        if simulated is not True:
            print simulated
            sys.exit()
            
        else:
            #output treatment
            if commands.multi is True:
                inputs = [outputspath, config.sim_steps, config.warm_up_time, commands.verbose]
                results = define.createWorkers([f for f in os.listdir(outputspath) if f.endswith("fzp")], outputs.treatVissimOutputs, inputs, commands)            
                #building the old_data            
                for i in range(len(results)):
                    if i == 0:
                                            
                        old_nb_opp = [ results[i][1] ]
                        old_nb_man = [ results[i][2] ]
                        old_flow   = [ results[i][0] ]
                        old_FM     = [ results[i][3].distributions[j].raw for j in range(len(results[i][3].distributions)) if results[i][3].distributions[j] != [] ]
                        old_oppA   = [ results[i][4].distributions[j].raw for j in range(len(results[i][4].distributions)) if results[i][4].distributions[j] != [] ]
                        old_oppB   = [ results[i][5].distributions[j].raw for j in range(len(results[i][5].distributions)) if results[i][5].distributions[j] != [] ]
                        old_manA   = [ results[i][6].distributions[j].raw for j in range(len(results[i][6].distributions)) if results[i][6].distributions[j] != [] ]
                        old_manB   = [ results[i][7].distributions[j].raw for j in range(len(results[i][7].distributions)) if results[i][7].distributions[j] != [] ]
                                           
                    else:
                        old_nb_opp.append(results[i][1])
                        old_nb_man.append(results[i][2])
                        old_flow.append(results[i][0])
                        for j in range(len(results[i][3].distributions)):
                            if results[i][3].distributions[j] != []: old_FM.append(results[i][3].distributions[j].raw)
                        for j in range(len(results[i][4].distributions)):
                            if results[i][4].distributions[j] != []: old_oppA.append(results[i][4].distributions[j].raw)
                        for j in range(len(results[i][5].distributions)):
                            if results[i][5].distributions[j] != []: old_oppB.append(results[i][5].distributions[j].raw)
                        for j in range(len(results[i][6].distributions)):
                            if results[i][6].distributions[j] != []: old_manA.append(results[i][6].distributions[j].raw)
                        for j in range(len(results[i][7].distributions)):
                            if results[i][7].distributions[j] != []: old_manB.append(results[i][7].distributions[j].raw)
                       
                old_num    = iterrations_ran
                old_data   = [old_nb_opp, old_nb_man, old_flow, old_FM, old_oppA, old_oppB, old_manA, old_manB, old_num]
                inputs = [outputspath, config.sim_steps, config.warm_up_time, commands.verbose, old_data]
                flow, oppLCcount, manLCcount, forFMgap, oppLCagap, oppLCbgap, manLCagap, manLCbgap = outputs.treatVissimOutputs(None, inputs)
                                    
            else:
                inputs = [outputspath, config.sim_steps, config.warm_up_time, commands.verbose]
                flow, oppLCcount, manLCcount, forFMgap, oppLCagap, oppLCbgap, manLCagap, manLCbgap = outputs.treatVissimOutputs([f for f in os.listdir(outputspath) if f.endswith("fzp")], inputs)
       
    #Student t-test to find the min number of runs
    t_student = t.ppf(0.975,9)
    err = config.desired_pct_error/100

    N1 = ( t_student * forFMgap.cumul_all.std / (err * forFMgap.cumul_all.mean) )**2
    N2 = ( t_student * oppLCagap.cumul_all.std / (err * oppLCagap.cumul_all.mean) )**2
    N3 = ( t_student * oppLCbgap.cumul_all.std / (err * oppLCbgap.cumul_all.mean)  )**2
    N4 = ( t_student * manLCagap.cumul_all.std / (err * manLCagap.cumul_all.mean)  )**2
    N5 = ( t_student * manLCbgap.cumul_all.std / (err * manLCbgap.cumul_all.mean)  )**2
    
    #if all variables are to be statisticaly significant to 95% confidance, they must all pass the test, thus N1...N5 must be < than the number of runs
    N =  max(N1, N2, N3, N4, N5)    
    
    #std confidence intervals             
    SCI1 = [forFMgap.cumul_all.std*((N-1)/chi2.ppf(1-0.05/2,N-1))**0.5 ,  forFMgap.cumul_all.std*((N-1)/chi2.ppf(0.05/2,N-1))**0.5 ]
    SCI2 = [oppLCagap.cumul_all.std*((N-1)/chi2.ppf(1-0.05/2,N-1))**0.5 , oppLCagap.cumul_all.std*((N-1)/chi2.ppf(0.05/2,N-1))**0.5 ]   
    SCI3 = [oppLCbgap.cumul_all.std*((N-1)/chi2.ppf(1-0.05/2,N-1))**0.5 , oppLCbgap.cumul_all.std*((N-1)/chi2.ppf(0.05/2,N-1))**0.5 ]
    SCI4 = [manLCagap.cumul_all.std*((N-1)/chi2.ppf(1-0.05/2,N-1))**0.5 , manLCagap.cumul_all.std*((N-1)/chi2.ppf(0.05/2,N-1))**0.5 ]
    SCI5 = [manLCbgap.cumul_all.std*((N-1)/chi2.ppf(1-0.05/2,N-1))**0.5 , manLCbgap.cumul_all.std*((N-1)/chi2.ppf(0.05/2,N-1))**0.5 ]
    
    text.append(["Nbr_itt","Student-t","Std1","Mean1","N1","Std2","Mean2","N2","Std3","Mean3","N3","Std4","Mean4","N4","Std5","Mean5","N5","N","SCI1max","SCI1min","SCI2max","SCI2min","SCI3max","SCI3min","SCI4max","SCI4min","SCI5max","SCI5min"])
    text.append([iterrations_ran, t_student, forFMgap.cumul_all.std,forFMgap.cumul_all.mean, N1, oppLCagap.cumul_all.std, oppLCagap.cumul_all.mean, N2, oppLCbgap.cumul_all.std, oppLCbgap.cumul_all.mean, N3, manLCagap.cumul_all.std, manLCagap.cumul_all.mean, N4, manLCbgap.cumul_all.std, manLCbgap.cumul_all.mean, N5, N, SCI1, SCI2, SCI3, SCI4, SCI5])    
    
    while N > iterrations_ran and iterrations_ran < max_itt:
        
        if commands.verbose is True:
            print 'Starting the ' + str(iterrations_ran + 1) + "th iteration"        
        
        #building the old_data
        old_nb_opp = [oppLCcount]
        old_nb_man = [manLCcount]
        old_flow   = [flow]
        old_FM     = [ forFMgap.distributions[i].raw for i in range(len(forFMgap.distributions)) ]
        old_oppA   = [ oppLCagap.distributions[i].raw for i in range(len(oppLCagap.distributions)) ]
        old_oppB   = [ oppLCbgap.distributions[i].raw for i in range(len(oppLCbgap.distributions)) ]
        old_manA   = [ manLCagap.distributions[i].raw for i in range(len(manLCagap.distributions)) ]
        old_manB   = [ manLCbgap.distributions[i].raw for i in range(len(manLCbgap.distributions)) ]
        old_num    = iterrations_ran
        old_data   = [old_nb_opp, old_nb_man, old_flow, old_FM, old_oppA, old_oppB, old_manA, old_manB, old_num]        
        
        #incrementing needed parameters                
        parameters[1] = first_seed + iterrations_ran    #need to increment the starting Rand Seed by the number of it. already ran
        parameters[2] = 1                               #need to do only one simulation
        iterrations_ran += 1
        
        #calling vissim
        if commands.mode:  #this serves to bypass Vissim while testing the code
            flow, oppLCcount, manLCcount, forFMgap, oppLCagap, oppLCbgap, manLCagap, manLCbgap = outputs.generateRandomOutputs(parameters)
        else:
            
            #Initialize the new Vissim simulation
            Simulation = Vissim.Simulation
            Simulation.SetAttValue("RandSeed", parameters[1])
            Simulation.SetAttValue("NumRuns", parameters[2])
                                
            #Starting the simulation            
            Simulation.RunContinuous()                                
            
            #determining current file
            file_to_run = ["Statistical_test_" + str(iterrations_ran).zfill(3) + ".fzp"]            

            #output treatment
            inputs = [outputspath, config.sim_steps, config.warm_up_time, commands.verbose, old_data]
            flow, oppLCcount, manLCcount, forFMgap, oppLCagap, oppLCbgap, manLCagap, manLCbgap = outputs.treatVissimOutputs(file_to_run, inputs)
        
        #generating the needed means and std
        t_student = t.ppf(0.975, iterrations_ran -1)
        N1 = ( t_student * forFMgap.cumul_all.std / (err * forFMgap.cumul_all.mean) )**2
        N2 = ( t_student * oppLCagap.cumul_all.std / (err * oppLCagap.cumul_all.mean) )**2
        N3 = ( t_student * oppLCbgap.cumul_all.std / (err * oppLCbgap.cumul_all.mean)  )**2
        N4 = ( t_student * manLCagap.cumul_all.std / (err * manLCagap.cumul_all.mean)  )**2
        N5 = ( t_student * manLCbgap.cumul_all.std / (err * manLCbgap.cumul_all.mean)  )**2
        
        N =  max(N1, N2, N3, N4, N5)        
        
        #std confidence intervals             
        SCI1 = [forFMgap.cumul_all.std*((N-1)/chi2.ppf(1-0.05/2,N-1))**0.5 ,  forFMgap.cumul_all.std*((N-1)/chi2.ppf(0.05/2,N-1))**0.5 ]
        SCI2 = [oppLCagap.cumul_all.std*((N-1)/chi2.ppf(1-0.05/2,N-1))**0.5 , oppLCagap.cumul_all.std*((N-1)/chi2.ppf(0.05/2,N-1))**0.5 ]   
        SCI3 = [oppLCbgap.cumul_all.std*((N-1)/chi2.ppf(1-0.05/2,N-1))**0.5 , oppLCbgap.cumul_all.std*((N-1)/chi2.ppf(0.05/2,N-1))**0.5 ]
        SCI4 = [manLCagap.cumul_all.std*((N-1)/chi2.ppf(1-0.05/2,N-1))**0.5 , manLCagap.cumul_all.std*((N-1)/chi2.ppf(0.05/2,N-1))**0.5 ]
        SCI5 = [manLCbgap.cumul_all.std*((N-1)/chi2.ppf(1-0.05/2,N-1))**0.5 , manLCbgap.cumul_all.std*((N-1)/chi2.ppf(0.05/2,N-1))**0.5 ]
        
        text.append([iterrations_ran, t_student, forFMgap.cumul_all.std,forFMgap.cumul_all.mean, N1, oppLCagap.cumul_all.std, oppLCagap.cumul_all.mean, N2, oppLCbgap.cumul_all.std, oppLCbgap.cumul_all.mean, N3, manLCagap.cumul_all.std, manLCagap.cumul_all.mean, N4, manLCbgap.cumul_all.std, manLCbgap.cumul_all.mean, N5, N, SCI1, SCI2, SCI3, SCI4, SCI5])     
        
    if iterrations_ran == max_itt and commands.verbose is True:
        print "Maximum number of iterations reached - Stoping calculations and generating report"
    elif commands.verbose is True:
        print "Statistical precision achieved - generating report"     
                
    #closing vissim
    vissim.stopVissim(Vissim)

    '''
    MUST ADD GRAPH OPTION
    '''
    
    return text        
        

################################ 
#        Sensitivity Analisis       
################################

def setCalculatingValues(default_values, current_name, nbr_points, current_range = [], default = False):
    '''Creates the working array to work with for the current iteration 
       NB: current_range = [[min, max], pos]  | for default_values = True, current_range is not needed'''
    
    working_values = copy.deepcopy(default_values)
    if default is True:        
        points_array = [default_values[0]]
        position = 0
    else:
        position = current_range[1]
        if current_name == "CoopLnChg":
            points_array = current_range[0]
        else:
            points_array = []
            if nbr_points > 1:
                for point in range(nbr_points):
                    points_array.append(current_range[0][0] + point * (current_range[0][1] - current_range[0][0]) /  (nbr_points - 1) )
            else:
                points_array.append((current_range[0][0] + current_range[0][1]) / 2)
            
    return working_values, points_array, position
        
def varDict(variable_names, default_values):
    '''creates a dictionary for faster search of variables'''
    
    var_dict = {}
    for i in range(len(variable_names)):
        var_dict[variable_names[i]] = [default_values[i], i]
        
    return var_dict    
        
def correctingValues(default_values, current_value, current_name, var_dict):
    '''Checks if the value is in the following list and corrects the linked values accordingly'''
    
    message = []
    working_values = copy.deepcopy(default_values)
    if current_name == "CoopLnChgSpeedDiff":
        working_values[var_dict["CoopLnChg"][1]] = True
    elif current_name == "CoopLnChgCollTm":
        working_values[var_dict["CoopLnChg"][1]] = True
    elif current_name == "LookAheadDistMin":
        if working_values[var_dict["LookAheadDistMax"][1]] < current_value:
            working_values[var_dict["LookAheadDistMax"][1]] = current_value + 0.1
            message.append('LookAheadDistMax was set to a value lower than the value set to LookAheadDistMin. To avoid a crash of Vissim, the value was adjusted')
    elif current_name == "LookAheadDistMax":
        if working_values[var_dict["LookAheadDistMin"][1]] > current_value:
            working_values[var_dict["LookAheadDistMin"][1]] = current_value - 0.1
            message.append('LookAheadDistMin was set to a value higher than the value set to LookAheadDistMax. To avoid a crash of Vissim, the value was adjusted')
    elif current_name == "LookBackDistMin":
        if working_values[var_dict["LookBackDistMax"][1]] < current_value:
            working_values[var_dict["LookBackDistMax"][1]] = current_value + 0.1
            message.append('LookBackDistMax was set to a value lower than the value set to LookBackDistMin. To avoid a crash of Vissim, the value was adjusted')
    elif current_name == "LookBackDistMax":
        if working_values[var_dict["LookBackDistMin"][1]] > current_value:
            working_values[var_dict["LookBackDistMin"][1]] = current_value - 0.1
            message.append('LookBackDistMin was set to a value higher than the value set to LookBackDistMax. To avoid a crash of Vissim, the value was adjusted')
        
    return working_values, message

def prepareFolderforVissimAnalysis(outputspath, folder_name, InpxName, InpxPath, default = False):
    #creating a folder containing the files for that iteration
    if default is True:
        filename = 'Default_values.inpx'
        folder = 'Default_values'
    else:
        filename = folder_name + '.inpx'
        folder = folder_name

    folderpath = os.path.join(outputspath, folder)
    newfolderpath = write.createSubFolder(folderpath, folder)
    
    if newfolderpath is False:
        print 'Newfolderpath = False, must find a way to handle this issue'
        sys.exit()
    
    #renaming the inpx and moving it to the new folder
    if os.path.exists(os.path.join(folderpath, filename)) is False:
        shutil.copy(InpxPath, os.path.join(folderpath, InpxName))
        os.rename(os.path.join(folderpath, InpxName), os.path.join(folderpath, filename))
    
    return folderpath, filename

def monteCarlo(valuesVector, inputs):
    concat_variables    = inputs [0]
    InpxPath            = inputs [1]
    InpxName            = inputs [2]
    outputspath         = inputs [3]
    config              = inputs [4]
    commands            = inputs [5]
    running             = inputs [6]
    parameters          = inputs [7]
    lowerbound          = inputs [8]
    
    #preparing the outputs    
    text = []
            
    #analysing the values
    for value in range(len(valuesVector)):        
        #creating a folder containing the files for that iteration
    
        if commands.multi:
            for i in range(len(inputs[9])):
                if valuesVector == inputs[9][i]:
                    lowerbound += len(inputs[9][i]*i)
                    
    
        folderpath, filename = prepareFolderforVissimAnalysis(outputspath, 'point_' + str(value+lowerbound), InpxName, InpxPath)
    
        #Starting a Vissim instance
        if commands.mode:  #this serves to bypass Vissim while testing the code
            flow, oppLCcount, manLCcount, forFMgap, oppLCagap, oppLCbgap, manLCagap, manLCbgap = outputs.generateRandomOutputs(parameters)
        else:
            if running is False:
                Vissim = vissim.startVissim(running, os.path.join(folderpath, filename))
                running = True
            else:
                Vissim.LoadNet (os.path.join(folderpath, filename))
                                
            #Vissim initialisation and simulation running
            simulated = vissim.initializeSimulation(Vissim, parameters, valuesVector[value], concat_variables, commands.save_swp)
            
            if simulated is not True:
                text.append([value, valuesVector[value],''.join(str(simulated))])    #printing the exception in the csv file
            else:                                
                #output treatment
                inputs = [folderpath, config.sim_steps, config.warm_up_time, commands.verbose]
                flow, oppLCcount, manLCcount, forFMgap, oppLCagap, oppLCbgap, manLCagap, manLCbgap = outputs.treatVissimOutputs([f for f in os.listdir(folderpath) if f.endswith("fzp")], inputs)            

                #writing to file
                text.append([value, valuesVector[value], flow, oppLCcount, manLCcount, forFMgap.cumul_all.mean, oppLCagap.cumul_all.mean, oppLCbgap.cumul_all.mean, manLCagap.cumul_all.mean, manLCbgap.cumul_all.mean])       

    #closing Vissim
    vissim.stopVissim(Vissim)
    
    return text
	
def sensitivityAnalysis(rangevalues, inputs, default = False):
    '''Runs the sensitivity analysis for a set of predetermined values
    
       note: rangevalues = [range, position in the complete list]
    '''    

    #unpacking inputs - should eventually be changed directly in the code
    concat_variables    = inputs [0]
    default_values      = inputs [1]
    InpxPath            = inputs [2]
    InpxName            = inputs [3]
    outputspath         = inputs [4]
    graphspath          = inputs [5]
    config              = inputs [6]
    commands            = inputs [7]
    running             = inputs [8]
    parameters          = inputs [9]
    verbose             = inputs [10]
    if default is False:
        firstrun_results = inputs[11]      
    
    #preparing the outputs    
    text = []
    if commands.multi is True and default is False:
        #opening a process output file
        WorkingPath = outputspath.strip(os.sep+'outputs')
        multiProcTempFile = outputspath.split(os.sep)[-2] + '_ProcTempFile_' + concat_variables[rangevalues[0][1]]
        out, subdirname = write.writeHeader(WorkingPath, concat_variables, "Sensitivity", config.first_seed, config.nbr_runs, config.warm_up_time, config.simulation_time, InpxName, default_values, multiProcTempFile)       
    
    #creating a dictionnary
    var_dict = varDict(concat_variables, default_values)    

    #treating the values given in rangevalues    
    for value in range(len(rangevalues)):        
        #defining the variable being worked on and the range of values it can take
        if default is True:
            current_range = []
            value_name = "Default"
        else:
            current_range = rangevalues[value]   
            value_name = concat_variables[rangevalues[value][1]]
        
        #defining the values needed for the current cycle
        working_values, points_array, position = setCalculatingValues(default_values, value_name, config.nbr_points, current_range, default)

        #iterating on the number points
        for point in points_array:
            iteration_values = copy.deepcopy(working_values)
            iteration_values[position] = point
            
            #correcting the value array for variables that need to interact with others
            corrected_values, message = correctingValues(iteration_values, point, value_name, var_dict)
            
            if message != []:
                print'*** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***' 
                print message
                print' occured for variable ' + str(value_name) + ' = ' + str(point) 
                print'*** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***'
            
            #creating a folder containing the files for that iteration
            folderpath, filename = prepareFolderforVissimAnalysis(outputspath, value_name + '_' + str(round(point,3)), InpxName, InpxPath, default)
    
            #Starting a Vissim instance
            if commands.mode:  #this serves to bypass Vissim while testing the code
                flow, oppLCcount, manLCcount, forFMgap, oppLCagap, oppLCbgap, manLCagap, manLCbgap = outputs.generateRandomOutputs(parameters)
            else:
                #Vissim starting and loading network block
                Vissim = vissim.startVissim(running, os.path.join(folderpath, filename))                
                if Vissim == 'StartError':
                    if default is True:
                        print 'Could not start Vissim for default values, shutting down the analysis'
                        sys.exit()
                    else:
                        text.append([value_name, corrected_values,'Could not start Vissim'])
                        continue
                elif Vissim == 'LoadNetError':
                    if default is True:
                        print 'Could not load the Network for default values, shutting down the analysis'
                        sys.exit()
                    else:
                        text.append([value_name, corrected_values,'Could not load the Network'])
                        continue
                else:
                    #preventing a new loading of Vissim for that iteration
                    running = True
                    
                    #Vissim initialisation and simulation running
                    simulated = vissim.initializeSimulation(Vissim, parameters, corrected_values, concat_variables, commands.save_swp)
                    if simulated is not True:
                        text.append([value_name, corrected_values,''.join(str(simulated))])    #printing the exception in the csv file
                        continue
                    else:
                        #output treatment
                        inputs = [folderpath, config.sim_steps, config.warm_up_time, verbose]
                        flow, oppLCcount, manLCcount, forFMgap, oppLCagap, oppLCbgap, manLCagap, manLCbgap = outputs.treatVissimOutputs([f for f in os.listdir(folderpath) if f.endswith("fzp")], inputs)
                        #print '*** Output treatment completed *** Runtime: ' + str(time.clock())
                
            if default is True:
                firstrun_results = []
                firstrun_results.append(float(forFMgap.cumul_all.mean))
                firstrun_results.append(float(forFMgap.cumul_all.firstQuart))
                firstrun_results.append(float(forFMgap.cumul_all.median))
                firstrun_results.append(float(forFMgap.cumul_all.thirdQuart))
                firstrun_results.append(float(forFMgap.cumul_all.std))
                
                firstrun_results.append(float(oppLCagap.cumul_all.mean))
                firstrun_results.append(float(oppLCagap.cumul_all.firstQuart))
                firstrun_results.append(float(oppLCagap.cumul_all.median))
                firstrun_results.append(float(oppLCagap.cumul_all.thirdQuart))
                firstrun_results.append(float(oppLCagap.cumul_all.std))
                
                firstrun_results.append(float(oppLCbgap.cumul_all.mean))
                firstrun_results.append(float(oppLCbgap.cumul_all.firstQuart))
                firstrun_results.append(float(oppLCbgap.cumul_all.median))
                firstrun_results.append(float(oppLCbgap.cumul_all.thirdQuart))                
                firstrun_results.append(float(oppLCbgap.cumul_all.std))
                
                firstrun_results.append(float(manLCagap.cumul_all.mean))
                firstrun_results.append(float(manLCagap.cumul_all.firstQuart))
                firstrun_results.append(float(manLCagap.cumul_all.median))
                firstrun_results.append(float(manLCagap.cumul_all.thirdQuart))                
                firstrun_results.append(float(manLCagap.cumul_all.std))
                
                firstrun_results.append(float(manLCbgap.cumul_all.mean))
                firstrun_results.append(float(manLCbgap.cumul_all.firstQuart))
                firstrun_results.append(float(manLCbgap.cumul_all.median))
                firstrun_results.append(float(manLCbgap.cumul_all.thirdQuart))                
                firstrun_results.append(float(manLCbgap.cumul_all.std))
                
                firstrun_results.append(float(oppLCcount))
                firstrun_results.append(float(manLCcount))
                
            else:           
                delta_mean_fgap         = (forFMgap.cumul_all.mean       - firstrun_results[0])/firstrun_results[0]
                delta_firstQuart_fgap   = (forFMgap.cumul_all.firstQuart - firstrun_results[0])/firstrun_results[0]
                delta_median_fgaps      = (forFMgap.cumul_all.median     - firstrun_results[0])/firstrun_results[0]
                delta_thirdQuart_fgaps  = (forFMgap.cumul_all.thirdQuart - firstrun_results[0])/firstrun_results[0]
                delta_std_fgaps         = (forFMgap.cumul_all.std        - firstrun_results[0])/firstrun_results[0]
                
                delta_mean_Aoppgap        = (oppLCagap.cumul_all.mean       - firstrun_results[1])/firstrun_results[1]
                delta_firstQuart_Aoppgap  = (oppLCagap.cumul_all.firstQuart - firstrun_results[1])/firstrun_results[1]
                delta_median_Aoppgap      = (oppLCagap.cumul_all.median     - firstrun_results[1])/firstrun_results[1]
                delta_thirdQuart_Aoppgap  = (oppLCagap.cumul_all.thirdQuart - firstrun_results[1])/firstrun_results[1]
                delta_std_Aoppgap         = (oppLCagap.cumul_all.std        - firstrun_results[1])/firstrun_results[1]
                
                delta_mean_Boppgap        = (oppLCbgap.cumul_all.mean       - firstrun_results[2])/firstrun_results[2]
                delta_firstQuart_Boppgap  = (oppLCbgap.cumul_all.firstQuart - firstrun_results[2])/firstrun_results[2]
                delta_median_Boppgap      = (oppLCbgap.cumul_all.median     - firstrun_results[2])/firstrun_results[2]
                delta_thirdQuart_Boppgap  = (oppLCbgap.cumul_all.thirdQuart - firstrun_results[2])/firstrun_results[2]
                delta_std_Boppgap         = (oppLCbgap.cumul_all.std        - firstrun_results[2])/firstrun_results[2]
                
                #import pdb; pdb.set_trace()
                delta_mean_Amangap        = (manLCagap.cumul_all.mean       - firstrun_results[3])/firstrun_results[3]
                delta_firstQuart_Amangap  = (manLCagap.cumul_all.firstQuart - firstrun_results[3])/firstrun_results[3]
                delta_median_Amangap      = (manLCagap.cumul_all.median     - firstrun_results[3])/firstrun_results[3]
                delta_thirdQuart_Amangap  = (manLCagap.cumul_all.thirdQuart - firstrun_results[3])/firstrun_results[3]
                delta_std_Amangap         = (manLCagap.cumul_all.std        - firstrun_results[3])/firstrun_results[3]
                
                delta_mean_Bmangap        = (manLCbgap.cumul_all.mean       - firstrun_results[4])/firstrun_results[4]
                delta_firstQuart_Bmangap  = (manLCbgap.cumul_all.firstQuart - firstrun_results[4])/firstrun_results[4]
                delta_median_Bmangap      = (manLCbgap.cumul_all.median     - firstrun_results[4])/firstrun_results[4]
                delta_thirdQuart_Bmangap  = (manLCbgap.cumul_all.thirdQuart - firstrun_results[4])/firstrun_results[4]
                delta_std_Bmangap         = (manLCbgap.cumul_all.std        - firstrun_results[4])/firstrun_results[4]
                
                delta_oppLCcount = (oppLCcount - firstrun_results[5])/firstrun_results[5]
                
                delta_manLCcount = (manLCcount - firstrun_results[6])/firstrun_results[6]
            
            #printing graphs
            if commands.vis_save:
                variables = [forFMgap,oppLCagap,oppLCbgap,manLCagap,manLCbgap]
                variables_name =["Forward_gaps","Opportunistic_lane_change_'after'_gaps","Opportunistic_lane_change_'before'_gaps","Mandatory_lane_change_'after'_gaps","Mandatory_lane_change_'before'_gaps"]
                for var in range(len(variables)):
                    if default is True:
                        name = "Default_values"
                        subpath = "Default_values"
                    else:
                        name = filename.strip('.inpx')
                        subpath = value_name[:]
                    
                    write.printStatGraphs(graphspath,variables[var], name, variables_name[var], commands.fig_format, config.nbr_runs, subpath)
                    
            #writing to file
            if default is True:
                text.append(["Default_values", corrected_values, flow, oppLCcount, "---", manLCcount, "---",
                             forFMgap.cumul_all.mean,  "---", forFMgap.cumul_all.firstQuart,  "---", forFMgap.cumul_all.median,  "---", forFMgap.cumul_all.thirdQuart,  "---", forFMgap.cumul_all.std,  "---",
                             oppLCagap.cumul_all.mean, "---", oppLCagap.cumul_all.firstQuart, "---", oppLCagap.cumul_all.median, "---", oppLCagap.cumul_all.thirdQuart, "---", oppLCagap.cumul_all.std, "---",
                             oppLCbgap.cumul_all.mean, "---", oppLCbgap.cumul_all.firstQuart, "---", oppLCbgap.cumul_all.median, "---", oppLCbgap.cumul_all.thirdQuart, "---", oppLCbgap.cumul_all.std, "---",
                             manLCagap.cumul_all.mean, "---", manLCagap.cumul_all.firstQuart, "---", manLCagap.cumul_all.median, "---", manLCagap.cumul_all.thirdQuart, "---", manLCagap.cumul_all.std, "---",
                             manLCbgap.cumul_all.mean, "---", manLCbgap.cumul_all.firstQuart, "---", manLCbgap.cumul_all.median, "---", manLCbgap.cumul_all.thirdQuart, "---", manLCbgap.cumul_all.std, "---"])       

            else:
                text.append([value_name, corrected_values, flow,oppLCcount, delta_oppLCcount, manLCcount, delta_manLCcount,
                             forFMgap.cumul_all.mean,  delta_mean_fgap,    forFMgap.cumul_all.firstQuart,  delta_firstQuart_fgap,    forFMgap.cumul_all.median,  delta_median_fgaps,   forFMgap.cumul_all.thirdQuart,  delta_thirdQuart_fgaps,   forFMgap.cumul_all.std,  delta_std_fgaps,
                             oppLCagap.cumul_all.mean, delta_mean_Aoppgap, oppLCagap.cumul_all.firstQuart, delta_firstQuart_Aoppgap, oppLCagap.cumul_all.median, delta_median_Aoppgap, oppLCagap.cumul_all.thirdQuart, delta_thirdQuart_Aoppgap, oppLCagap.cumul_all.std, delta_std_Aoppgap,
                             oppLCbgap.cumul_all.mean, delta_mean_Boppgap, oppLCbgap.cumul_all.firstQuart, delta_firstQuart_Boppgap, oppLCbgap.cumul_all.median, delta_median_Boppgap, oppLCbgap.cumul_all.thirdQuart, delta_thirdQuart_Boppgap, oppLCbgap.cumul_all.std, delta_std_Boppgap,
                             manLCagap.cumul_all.mean, delta_mean_Amangap, manLCagap.cumul_all.firstQuart, delta_firstQuart_Amangap, manLCagap.cumul_all.median, delta_median_Amangap, manLCagap.cumul_all.thirdQuart, delta_thirdQuart_Amangap, manLCagap.cumul_all.std, delta_std_Amangap,
                             manLCbgap.cumul_all.mean, delta_mean_Bmangap, manLCbgap.cumul_all.firstQuart, delta_firstQuart_Bmangap, manLCbgap.cumul_all.median, delta_median_Bmangap, manLCbgap.cumul_all.thirdQuart, delta_thirdQuart_Bmangap, manLCbgap.cumul_all.std, delta_std_Bmangap])       
        
        #breaking the outer loop because the default only needs to be ran once
        if default is True:
            break
        
    vissim.stopVissim(Vissim)
    
    if commands.multi is True and default is False:
        for i in range(len(text)):
            write.writeInFile(out, text[i])  
        out.close()
        
    if default is True:  
        return text, firstrun_results
    else:
        return text